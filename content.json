{"posts":[{"title":"vim使用","text":"vim自用热键方案mac平台快捷键 非代码编辑区 12345678910111213141516171819202122232425262728293031323334cmd + g c ： 显示命令面板cmd + g s ： 打开设置页面cmd + g k ： 打开热键映射cmd + g m ： 打开一个目录cmd + g f ： 打开一个文件cmd + g h ： 打开最近记录cmd + g n ： 新建vscode实例cmd + g q ： 关闭vscode示例​cmd + f n ： 新建文件cmd + f o ： 打开文件cmd + f e ： 另存为文件cmd + f s ： 保存文件cmd + f w ： 保存所有文件cmd + f q ： 关闭文件cmd + f a ： 关闭所有文件​cmd + n [ ： 切换侧边栏显示状态cmd + n 1 ： 显示文件资源管理器cmd + n 2 ： 显示TODO Treecmd + n 3 ： 显示全局搜索cmd + n 4 ： 显示debugcmd + n 5 ： 显示版本控制cmd + n 6 ： 显示SQL Toolscmd + n 7 ： 显示Dockercmd + n 8 ： 显示测试cmd + n 9 ： 显示插件商店​cmd + p ] ： 切换面板显示状态cmd + p 1 ： 显示问题cmd + p 2 ： 显示输出cmd + p 3 ： 显示终端cmd + p 4 ： 显示调试控制台cmd + p 5 ： 显示SQL CONSOLE 代码编辑区 1234567891011121314cmd + q ：关闭当前选项卡或分屏 cmd + e ：聚焦在第一个选项卡中 cmd + , ：切换到上一个选项卡 cmd + . ：切换到下一个选项卡 ​ cmd + w s ：拆分一个上下分屏 cmd + w v ：拆分一个左右分屏 ​ cmd + w k ：将光标向上移动1屏 cmd + w j ：将光标向下移动1屏 ​ cmd + w h ：将光标向左移动1屏 cmd + w l ：将光标向右移动1屏 代码控制区 123456789101112131415161718192021cmd + h ： 触发帮助提示cmd + j ： 触发参数提示cmd + k ： 触发建议提示cmd + n ： 移动到下一个建议cmd + p ： 移动到上一个建议tab ： 选择下一个建议enter ： 选择当前建议​cmd + alt + l ： 格式化代码（个人习惯）​cmd + = ： 放大字体cmd + - ： 缩小字体jj ： 退出INSERT模式zz ： 切换代码折叠（原生vim的zz不是切换折叠）​H ：跳转行首、取代^L ：跳转行尾、取代$​g[ ： 跳转到上一个问题g] ： 跳转到下一个问题 另外还有一些指令例如在非视图模式下无法进行全选、复制、粘贴等功能 附vscode中keybinding.json的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473// 将键绑定放在此文件中以覆盖默认值[ // --- 全局命令 // 显示命令面板 { &quot;key&quot;: &quot;cmd+g c&quot;, &quot;command&quot;: &quot;workbench.action.showCommands&quot; }, // 打开设置页面 { &quot;key&quot;: &quot;cmd+g s&quot;, &quot;command&quot;: &quot;workbench.action.openSettings&quot; }, // 打开热键映射 { &quot;key&quot;: &quot;cmd+g k&quot;, &quot;command&quot;: &quot;workbench.action.openGlobalKeybindings&quot; }, // 打开一个目录 { &quot;key&quot;: &quot;cmd+g m&quot;, &quot;command&quot;: &quot;workbench.action.files.openFolder&quot; }, // 打开一个文件 { &quot;key&quot;: &quot;cmd+g f&quot;, &quot;command&quot;: &quot;workbench.action.files.openFile&quot; }, // 打开最近记录 { &quot;key&quot;: &quot;cmd+g h&quot;, &quot;command&quot;: &quot;workbench.action.openRecent&quot; }, // 新建vscode实例 { &quot;key&quot;: &quot;cmd+g n&quot;, &quot;command&quot;: &quot;workbench.action.newWindow&quot; }, // 关闭vscode实例 { &quot;key&quot;: &quot;cmd+g q&quot;, &quot;command&quot;: &quot;workbench.action.closeWindow&quot; }, // --- 文件命令 // 新建文件 { &quot;key&quot;: &quot;cmd+f n&quot;, &quot;command&quot;: &quot;welcome.showNewFileEntries&quot;, }, // 打开文件 { &quot;key&quot;: &quot;cmd+f o&quot;, &quot;command&quot;: &quot;workbench.action.files.openFileFolder&quot; }, // 另存为文件 { &quot;key&quot;: &quot;cmd+f e&quot;, &quot;command&quot;: &quot;workbench.action.files.saveAs&quot; }, // 保存文件 { &quot;key&quot;: &quot;cmd+f s&quot;, &quot;command&quot;: &quot;workbench.action.files.save&quot; }, // 保存所有文件 { &quot;key&quot;: &quot;cmd+f w&quot;, &quot;command&quot;: &quot;workbench.action.files.saveAll&quot; }, // 关闭文件 { &quot;key&quot;: &quot;cmd+f q&quot;, &quot;command&quot;: &quot;workbench.action.closeActiveEditor&quot; }, // 关闭所有文件 { &quot;key&quot;: &quot;cmd+f a&quot;, &quot;command&quot;: &quot;workbench.action.closeAllEditors&quot; }, // -- 侧边栏命令 // 切换侧边栏显示状态 { &quot;key&quot;: &quot;cmd+n [&quot;, &quot;command&quot;: &quot;workbench.action.toggleSidebarVisibility&quot; }, // 显示文件资源管理器 { &quot;key&quot;: &quot;cmd+n 1&quot;, &quot;command&quot;: &quot;workbench.files.action.focusFilesExplorer&quot; }, // 显示TODO Tree { &quot;key&quot;: &quot;cmd+n 2&quot;, &quot;command&quot;: &quot;todo-tree-view.focus&quot; }, // 显示全局搜索 { &quot;key&quot;: &quot;cmd+n 3&quot;, &quot;command&quot;: &quot;workbench.action.replaceInFiles&quot;, }, // 显示debug { &quot;key&quot;: &quot;cmd+n 4&quot;, &quot;command&quot;: &quot;workbench.view.debug&quot;, &quot;when&quot;: &quot;viewContainer.workbench.view.debug.enabled&quot; }, // 显示版本控制 { &quot;key&quot;: &quot;cmd+n 5&quot;, &quot;command&quot;: &quot;workbench.view.scm&quot;, &quot;when&quot;: &quot;workbench.scm.active&quot; }, // 显示SQL Tools { &quot;key&quot;: &quot;cmd+n 6&quot;, &quot;command&quot;: &quot;workbench.view.extension.sqltoolsActivityBarContainer&quot; }, // 显示Docker { &quot;key&quot;: &quot;cmd+n 7&quot;, &quot;command&quot;: &quot;workbench.view.extension.dockerView&quot; }, // 显示测试 { &quot;key&quot;: &quot;cmd+n 8&quot;, &quot;command&quot;: &quot;workbench.view.testing.focus&quot; }, // 显示插件商店 { &quot;key&quot;: &quot;cmd+n 9&quot;, &quot;command&quot;: &quot;workbench.view.extensions&quot;, &quot;when&quot;: &quot;viewContainer.workbench.view.extensions.enabled&quot; }, // --- 面板命令 // 切换面板显示状态 { &quot;key&quot;: &quot;cmd+p [&quot;, &quot;command&quot;: &quot;workbench.action.togglePanel&quot; }, // 显示问题 { &quot;key&quot;: &quot;cmd+p 1&quot;, &quot;command&quot;: &quot;workbench.panel.markers.view.focus&quot; }, // 显示输出 { &quot;key&quot;: &quot;cmd+p 2&quot;, &quot;command&quot;: &quot;workbench.action.output.toggleOutput&quot;, &quot;when&quot;: &quot;workbench.panel.output.active&quot; }, // 显示终端 { &quot;key&quot;: &quot;cmd+p 3&quot;, &quot;command&quot;: &quot;workbench.action.terminal.toggleTerminal&quot;, &quot;when&quot;: &quot;terminal.active&quot; }, // 显示调试控制台 { &quot;key&quot;: &quot;cmd+p 4&quot;, &quot;command&quot;: &quot;workbench.debug.action.toggleRepl&quot;, &quot;when&quot;: &quot;workbench.panel.repl.view.active&quot; }, // 显示SQL CONSOLE { &quot;key&quot;: &quot;cmd+p 5&quot;, &quot;command&quot;: &quot;workbench.view.extension.sqltoolsPanelContainer&quot; }, // --- 编辑区命令 // 关闭当前选项卡或分屏 { &quot;key&quot;: &quot;cmd+q&quot;, &quot;command&quot;: &quot;workbench.action.closeActiveEditor&quot; }, // 聚集在第一个选项卡中 { &quot;key&quot;: &quot;cmd+e&quot;, &quot;command&quot;: &quot;workbench.action.focusFirstEditorGroup&quot; }, // 切换到上一个选项卡 { &quot;key&quot;: &quot;cmd+,&quot;, &quot;command&quot;: &quot;workbench.action.previousEditor&quot; }, // 切换到下一个选项卡 { &quot;key&quot;: &quot;cmd+.&quot;, &quot;command&quot;: &quot;workbench.action.nextEditor&quot; }, // 拆分一个上下分屏 { &quot;key&quot;: &quot;cmd+w s&quot;, &quot;command&quot;: &quot;workbench.action.splitEditorDown&quot; }, // 拆分一个左右分屏 { &quot;key&quot;: &quot;cmd+w v&quot;, &quot;command&quot;: &quot;workbench.action.splitEditor&quot; }, // 将光标向上动1屏 { &quot;key&quot;: &quot;cmd+w k&quot;, &quot;command&quot;: &quot;workbench.action.focusAboveGroup&quot; }, // 将光标向下动1屏 { &quot;key&quot;: &quot;cmd+w j&quot;, &quot;command&quot;: &quot;workbench.action.focusBelowGroup&quot; }, // 将光标向左移动1屏 { &quot;key&quot;: &quot;cmd+w h&quot;, &quot;command&quot;: &quot;workbench.action.focusLeftGroup&quot; }, // 将光标向右移动1屏 { &quot;key&quot;: &quot;cmd+w l&quot;, &quot;command&quot;: &quot;workbench.action.focusRightGroup&quot; }, // --- 代码编辑命令 // 触发帮助提示 { &quot;key&quot;: &quot;cmd+h&quot;, &quot;command&quot;: &quot;editor.action.showHover&quot;, &quot;when&quot;: &quot;editorTextFocus&quot; }, // 触发参数提示 { &quot;key&quot;: &quot;cmd+j&quot;, &quot;command&quot;: &quot;editor.action.triggerParameterHints&quot;, &quot;when&quot;: &quot;editorHasSignatureHelpProvider &amp;&amp; editorTextFocus&quot; }, { &quot;key&quot;: &quot;cmd+j&quot;, &quot;command&quot;: &quot;closeParameterHints&quot;, &quot;when&quot;: &quot;editorFocus &amp;&amp; parameterHintsVisible&quot; }, // 触发建议提示 { &quot;key&quot;: &quot;cmd+k&quot;, &quot;command&quot;: &quot;editor.action.triggerSuggest&quot;, &quot;when&quot;: &quot;editorHasCompletionItemProvider &amp;&amp; textInputFocus &amp;&amp; !editorReadonly&quot; }, { &quot;key&quot;: &quot;cmd+k&quot;, &quot;command&quot;: &quot;hideSuggestWidget&quot;, &quot;when&quot;: &quot;suggestWidgetVisible &amp;&amp; textInputFocus&quot; }, // 移动到下一个建议 { &quot;key&quot;: &quot;cmd+n&quot;, &quot;command&quot;: &quot;selectNextSuggestion&quot;, &quot;when&quot;: &quot;suggestWidgetMultipleSuggestions &amp;&amp; suggestWidgetVisible &amp;&amp; textInputFocus&quot; }, // 移动到上一个建议 { &quot;key&quot;: &quot;cmd+p&quot;, &quot;command&quot;: &quot;selectPrevSuggestion&quot;, &quot;when&quot;: &quot;suggestWidgetMultipleSuggestions &amp;&amp; suggestWidgetVisible &amp;&amp; textInputFocus&quot; }, // 格式化代码 { &quot;key&quot;: &quot;cmd+alt+l&quot;, &quot;command&quot;: &quot;editor.action.formatDocument&quot;, &quot;when&quot;: &quot;editorHasDocumentFormattingProvider &amp;&amp; editorTextFocus &amp;&amp; !editorReadonly &amp;&amp; !inCompositeEditor&quot; }, // 放大字体 { &quot;key&quot;: &quot;cmd+=&quot;, &quot;command&quot;: &quot;editor.action.fontZoomIn&quot; }, // 缩小字体 { &quot;key&quot;: &quot;cmd+-&quot;, &quot;command&quot;: &quot;editor.action.fontZoomOut&quot; }, // --- window 用户删除以下重映射，这里是为MAC用户准备的 { &quot;key&quot;: &quot;cmd+r&quot;, &quot;command&quot;: &quot;extension.vim_ctrl+r&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-r&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;ctrl+r&quot;, &quot;command&quot;: &quot;-extension.vim_ctrl+r&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-r&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+a&quot;, &quot;command&quot;: &quot;extension.vim_ctrl+a&quot;, }, { &quot;key&quot;: &quot;ctrl+a&quot;, &quot;command&quot;: &quot;-extension.vim_ctrl+a&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-a&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+x&quot;, &quot;command&quot;: &quot;extension.vim_ctrl+x&quot;, }, { &quot;key&quot;: &quot;ctrl+x&quot;, &quot;command&quot;: &quot;-extension.vim_ctrl+x&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-x&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+u&quot;, &quot;command&quot;: &quot;extension.vim_ctrl+u&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-u&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;ctrl+u&quot;, &quot;command&quot;: &quot;-extension.vim_ctrl+u&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-u&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+d&quot;, &quot;command&quot;: &quot;extension.vim_ctrl+d&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-d&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;ctrl+d&quot;, &quot;command&quot;: &quot;-extension.vim_ctrl+d&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-d&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+i&quot;, &quot;command&quot;: &quot;extension.vim_ctrl+i&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-i&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;ctrl+i&quot;, &quot;command&quot;: &quot;-extension.vim_ctrl+i&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-i&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+o&quot;, &quot;command&quot;: &quot;extension.vim_ctrl+o&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-o&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;ctrl+o&quot;, &quot;command&quot;: &quot;-extension.vim_ctrl+o&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-o&gt; &amp;&amp; !inDebugRepl&quot; }, // --- 取消一些vim插件的额外功能 { &quot;key&quot;: &quot;cmd+a&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+a&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-a&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'&quot; }, { &quot;key&quot;: &quot;alt+cmd+down&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+alt+down&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;alt+cmd+up&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+alt+up&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+c&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+c&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.overrideCopy &amp;&amp; vim.use&lt;D-c&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+v&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+v&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-v&gt; &amp;&amp; vim.mode == ''CommandlineInProgress' !inDebugRepl' || editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-v&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode == 'SearchInProgressMode'&quot; }, { &quot;key&quot;: &quot;cmd+d&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+d&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-d&gt; &amp;&amp; !inDebugRepl&quot; }, { &quot;key&quot;: &quot;cmd+left&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+left&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-left&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'&quot; }, { &quot;key&quot;: &quot;cmd+right&quot;, &quot;command&quot;: &quot;-extension.vim_cmd+right&quot;, &quot;when&quot;: &quot;editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-right&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'&quot; }, // --- 取消或更改一些vscode键位 // cmd+a全选功能在非INSERT模式下不生效 { &quot;key&quot;: &quot;cmd+a&quot;, &quot;command&quot;: &quot;editor.action.selectAll&quot;, &quot;when&quot;: &quot;vim.mode != 'Normal' &amp;&amp; vim.mode != 'Visual' &amp;&amp; vim.mode != 'VisualLine' &amp;&amp; vim.mode != 'VisualBlock' &amp;&amp; vim.mode != 'CommandlineInProgress'&quot; }, { &quot;key&quot;: &quot;cmd+a&quot;, &quot;command&quot;: &quot;-editor.action.selectAll&quot; }, // cmd+c或者cmd+v功能在非INSERT模式下不生效 { &quot;key&quot;: &quot;cmd+c&quot;, &quot;command&quot;: &quot;-editor.action.clipboardCopyAction&quot; }, { &quot;key&quot;: &quot;cmd+v&quot;, &quot;command&quot;: &quot;-editor.action.clipboardPasteAction&quot; }, { &quot;key&quot;: &quot;cmd+c&quot;, &quot;command&quot;: &quot;-execCopy&quot; }, { &quot;key&quot;: &quot;cmd+c&quot;, &quot;command&quot;: &quot;execCopy&quot;, &quot;when&quot;: &quot;vim.mode != 'Normal' &amp;&amp; vim.mode != 'Visual' &amp;&amp; vim.mode != 'VisualLine' &amp;&amp; vim.mode != 'VisualBlock' &amp;&amp; vim.mode != 'CommandlineInProgress'&quot; }, { &quot;key&quot;: &quot;cmd+v&quot;, &quot;command&quot;: &quot;-execPaste&quot;, }, { &quot;key&quot;: &quot;cmd+v&quot;, &quot;command&quot;: &quot;execPaste&quot;, &quot;when&quot;: &quot;vim.mode != 'Normal' &amp;&amp; vim.mode != 'Visual' &amp;&amp; vim.mode != 'VisualLine' &amp;&amp; vim.mode != 'VisualBlock' &amp;&amp; vim.mode != 'CommandlineInProgress'&quot; }, // --- 资源管理器中对文件或目录的操作 // 新建文件 { &quot;key&quot;: &quot;i&quot;, &quot;command&quot;: &quot;explorer.newFile&quot;, &quot;when&quot;: &quot; explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus &quot; }, // 新建目录 { &quot;key&quot;: &quot;o&quot;, &quot;command&quot;: &quot;explorer.newFolder&quot;, &quot;when&quot;: &quot; explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus &quot; }, // 刷新资源管理器 { &quot;key&quot;: &quot;r&quot;, &quot;command&quot;: &quot;workbench.files.action.refreshFilesExplorer&quot;, &quot;when&quot;: &quot; explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus &quot; }, // 重命名文件或目录 { &quot;key&quot;: &quot;a&quot;, &quot;command&quot;: &quot;renameFile&quot;, &quot;when&quot;: &quot; explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus &quot; }, // 删除文件或目录 { &quot;key&quot;: &quot;d&quot;, &quot;command&quot;: &quot;deleteFile&quot;, &quot;when&quot;: &quot; explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus &quot; }, // 剪切文件或目录 { &quot;key&quot;: &quot;x&quot;, &quot;command&quot;: &quot;filesExplorer.cut&quot;, &quot;when&quot;: &quot;explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus&quot; }, // 复制文件或目录 { &quot;key&quot;: &quot;y&quot;, &quot;command&quot;: &quot;filesExplorer.copy&quot;, &quot;when&quot;: &quot;explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !inputFocus&quot; }, // 粘贴文件或目录 { &quot;key&quot;: &quot;p&quot;, &quot;command&quot;: &quot;filesExplorer.paste&quot;, &quot;when&quot;: &quot;explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus&quot; },] 附vim插件中settings.json配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104{ &quot;explorer.confirmDelete&quot;: false, &quot;go.useCodeSnippetsOnFunctionSuggest&quot;: true, &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;, &quot;go.toolsManagement.autoUpdate&quot;: true, &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;, &quot;editor.fontSize&quot;: 15, &quot;explorer.confirmDragAndDrop&quot;: false, &quot;workbench.startupEditor&quot;: &quot;none&quot;, &quot;bracketPairColorizer.depreciation-notice&quot;: false, &quot;workbench.colorTheme&quot;: &quot;Visual Studio Dark&quot;, &quot;files.autoSave&quot;: &quot;onFocusChange&quot;, &quot;[python]&quot;: { &quot;editor.formatOnType&quot;: true }, &quot;vim.digraphs&quot;: { }, // 绑定vim前导键 &quot;vim.leader&quot;: &quot;&lt;space&gt;&quot;, // 启用easymotion插件 &quot;vim.easymotion&quot;: true, // 启用系统粘贴板作为vim寄存器 &quot;vim.useSystemClipboard&quot;: true, // 由vim接管ctrl+any的按键，而不是vscode &quot;vim.useCtrlKeys&quot;: true, // 突出显示与当前搜索匹配的所有文本 &quot;vim.hlsearch&quot;: true, // 普通模式下的非递归按键绑定 &quot;vim.normalModeKeyBindingsNonRecursive&quot;: [ { &quot;before&quot;: [ &quot;H&quot; ], &quot;after&quot;: [ &quot;^&quot; ] }, { &quot;before&quot;: [ &quot;L&quot; ], &quot;after&quot;: [ &quot;$&quot; ] }, { &quot;before&quot;: [ &quot;z&quot;, &quot;z&quot;, ], &quot;commands&quot;: [ &quot;editor.toggleFold&quot; ] }, { &quot;before&quot;: [ &quot;g&quot;, &quot;[&quot;, ], &quot;commands&quot;: [ &quot;editor.action.marker.prevInFiles&quot; ] }, { &quot;before&quot;: [ &quot;g&quot;, &quot;]&quot;, ], &quot;commands&quot;: [ &quot;editor.action.marker.nextInFiles&quot; ] }, ], // 插入模式下的非递归按键绑定 // 将esc退出插入模式修改为jj退出插入模式 &quot;vim.insertModeKeyBindings&quot;: [ { &quot;before&quot;: [ &quot;j&quot;, &quot;j&quot; ], &quot;after&quot;: [ &quot;&lt;Esc&gt;&quot; ] }, ], // 命令模式下的非递归按键绑定 &quot;vim.commandLineModeKeyBindingsNonRecursive&quot;: [ ], // 可视模式下的非递归按键绑定 &quot;vim.operatorPendingModeKeyBindings&quot;: [], // 下面定义的按键将交由vscode进行处理，而不是vscode-vim插件 &quot;vim.handleKeys&quot;: { &quot;&lt;C-a&gt;&quot;: false, &quot;&lt;C-f&gt;&quot;: false }, &quot;vim.visualModeKeyBindings&quot;: [ ], &quot;vim.statusBarColors.easymotioninputmode&quot;: &quot;&quot;,} 插件输入法切换如果你在INSERT模式下使用中文输入法进行编辑，当ESC到NORMAL模式下后，它将依然保持中文输入法，这会使我们需要频繁的使用ctrl+shift或者cmd+space进行输入法切换，非常麻烦。 为了解决这个问题，你必须先在你的计算机上安装一个im-select脚本（根据官方文档来看，貌似只有mac和windows平台下存在这个问题）: 1curl -Ls https://raw.githubusercontent.com/daipeihust/im-select/master/install_mac.sh | sh 这个脚本有2个作用，当你输入im-select后它将获取当前输入法，当你输入im-select xxx后它将切换至xxx输入法。 首先你需要先切换到英文输入法中到终端执行im-select命令，并把结果保存下来： 12$ im-select com.apple.keylayout.ABC 然后再到settings.json中加入以下配置项即可完成输入法在INSERT模式以及NORMAL模式下的自动切换： 12345// 自动切换输入法 &quot;vim.autoSwitchInputMethod.enable&quot;: true, &quot;vim.autoSwitchInputMethod.defaultIM&quot;: &quot;com.apple.keylayout.ABC&quot;, // 这里输入你刚刚获得的英文输入法名称 &quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;: &quot;/usr/local/bin/im-select&quot;, &quot;vim.autoSwitchInputMethod.switchIMCmd&quot;: &quot;/usr/local/bin/im-select {im}&quot; 此文章在转载地址的基础上进行添加，并记录vim快捷键的思路，此思路在idea等软件上同样适用","link":"/2023/03/28/vim%E4%BD%BF%E7%94%A8/"},{"title":"git使用","text":"切换分支，如果不存在就创建。不加参数b则切换已有的分支 1git checkout -b volume_name 提交修改到缓存区。 确认提交信息 1git commit -m 'this is a commit msg' # 单次提交 合并提交 12git rebase -i 3fad3197 # 将commit信息以上的进行合并，但不包括3fad3197git rebase --abort # 废除合并 修改commit具体信息 1git commit --amend # 修改合并的具体信息，比如change_id设置为想要合并的原始chang_id 查看提交日志 12git log #查看提交日志 出现提交时代码已经更新 1234567891011121314151617git fetch # 拉取最新代码git stash save # 然后暂存本地修改git rebase origin/master # 把最新分支合并到当前分支git stash pop # 恢复本地暂存区代码其他方案：git status -s # 查看仓库状态# 添加需要提交的文件名（加路径--参考git status 打印出来的文件路径）git add src/components/文件名 git stash -u -k # 忽略其他文件，把现修改的隐藏起来，这样提交的时候就不会提交未被add的文件git commit -m &quot;哪里做了修改可写入...&quot;git pull # 拉取合并git push # 推送到远程仓库git stash pop # 恢复之前忽略的文件（非常重要的一步）# 其他方案：# 冲突之后会提示head文件，删除header部分注释，然后add，撤回提交，重新提交，git rebase --continue git stash 1# https://blog.csdn.net/stone_yw/article/details/80795669 撤销上一次提交 1git reset --soft HEAD^ 连接gerrit 12345678# 生成ssh密钥ssh-keygen -t rsa -C &quot;3200334@qq.com&quot;# 查看远程连接的地址git remote -v# 添加gerrit连接git remote add gerrit [url]# 参考：# https://stackoverflow.com/questions/19280472/git-review-doesnt-work-but-i-am-able-to-see-my-changes-when-i-do-a-push-what 如果第一次提交没有commit-id 1234567891011121314151617181920212223242526# 出现如下报错：# WARNING: Could not determine git version. Using modern git rebase# flags.# remote: # remote: Processing changes: refs: 1# remote: Processing changes: refs: 1, done # remote: ERROR: [5eebb2e] missing Change-Id in commit message footer # remote: # remote: Hint: To automatically insert Change-Id, install the hook: # remote: gitdir=$(git rev-parse --git-dir); scp -p -P 29418 sheye@review.ustack.com:hooks/commit-msg ${gitdir}/hooks/ # remote: And then amend the commit: # remote: git commit --amend # remote: # To ssh://review.ustack.com:29418/ued/silencer.git# ! [remote rejected] HEAD -&gt; refs/for/master%topic=repository_test ([5eebb2e] missing Change-Id in commit message footer)# error: failed to push some refs to 'ssh://review.ustack.com:29418/ued/silencer.git'# 解决方法：she@shedeMacBook-Air [20:36:44] [~/Desktop/goproject/silencer] [repository_test *]-&gt; % scp -p -P 29418 sheye@review.ustack.com:hooks/commit-msg .git/hooks/# 注释：如果之前的提交就没有commit-id，然后再设置的hook，首先回退这次提交（git reset --soft HEAD^）# ，重新提交hook才会生效。# 参考文档：# https://stackoverflow.com/questions/8845658/gerrit-error-when-change-id-in-commit-messages-are-missing 1234567891011121314151617181920212223242526# 出现如下报错：# WARNING: Could not determine git version. Using modern git rebase# flags.# remote: # remote: Processing changes: refs: 1# remote: Processing changes: refs: 1, done # remote: ERROR: [5eebb2e] missing Change-Id in commit message footer # remote: # remote: Hint: To automatically insert Change-Id, install the hook: # remote: gitdir=$(git rev-parse --git-dir); scp -p -P 29418 sheye@review.ustack.com:hooks/commit-msg ${gitdir}/hooks/ # remote: And then amend the commit: # remote: git commit --amend # remote: # To ssh://review.ustack.com:29418/ued/silencer.git# ! [remote rejected] HEAD -&gt; refs/for/master%topic=repository_test ([5eebb2e] missing Change-Id in commit message footer)# error: failed to push some refs to 'ssh://review.ustack.com:29418/ued/silencer.git'# 解决方法：she@shedeMacBook-Air [20:36:44] [~/Desktop/goproject/silencer] [repository_test *]-&gt; % scp -p -P 29418 sheye@review.ustack.com:hooks/commit-msg .git/hooks/# 注释：如果之前的提交就没有commit-id，然后再设置的hook，首先回退这次提交（git reset --soft HEAD^）# ，重新提交hook才会生效。# 参考文档：# https://stackoverflow.com/questions/8845658/gerrit-error-when-change-id-in-commit-messages-are-missing 解决冲突的几种方案： 12345678910111213141516171819202122231.出现以下提示：WARNING: Could not determine git version. Using modern git rebaseflags.Errors running git rebase --rebase-merges -i remotes/gerrit/masterRebasing (1/4)Rebasing (2/4)Rebasing (3/4)error: could not apply 76ffe7e... Add handler testResolve all conflicts manually, mark them as resolved with&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.You can instead skip this commit: run &quot;git rebase --skip&quot;.To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.Could not apply 76ffe7e... Add handler testCONFLICT (modify/delete): pkg/handler/license.go deleted in 76ffe7e (Add handler test) and modified in HEAD. Version HEAD of pkg/handler/license.go left in tree.It is likely that your change has a merge conflict. You may resolve itin the working tree now as described above and then run 'git review'again, or if you do not want to resolve it yet (note that the changecan not merge until the conflict is resolved) you may run 'git rebase--abort' then 'git review -R' to upload the change without rebasing.如果冲突文件在这次提交中无关紧要，可以直接移除，继续合并git add/rm &lt;conflicted_files&gt;git rebase --continue 添加远程地址: 1git remote add &lt;name&gt; &lt;url&gt; 产生冲突，结果产生变基： 1先删除掉《冲突符号，然后git rebase —continue然后再进行提交 提交时如果产生如下问题： 1234567891011121314-&gt; % git review WARNING: Could not determine git version. Using modern git rebaseflags.remote: remote: Processing changes: refs: 1, done To ssh://review.ustack.com:29418/devops/akali.git ! [remote rejected] HEAD -&gt; refs/for/master%topic=init (no common ancestry)error: failed to push some refs to 'ssh://review.ustack.com:29418/devops/akali.git'解决方案：git fetchgit rebase origin/master然后再按产生冲突的方式解决此错误可能是没有拉取头分支导致其他分支找不到头分支无法被提交 如果当前分支依赖上一个分支而不是主分支，而上一个分支被合并，可以将上个分支的提交drop在review 一直permission deni https://www.cnblogs.com/daibeisi/p/15662546.html https://stackoverflow.com/questions/25927914/git-error-please-make-sure-you-have-the-correct-access-rights-and-the-reposito","link":"/2023/03/23/git%E4%BD%BF%E7%94%A8/"},{"title":"goroutine&amp;channel","text":"前言应用程序通常需要 图形化界面异步执行一部分代码，以提升交互体验 需要并发地执行以提升效率 服务端并发处理连接，提升响应速度和qps 这些功能都是通过并发实现地，在Go语言中，每一个并发的执行单元叫作一个goroutine，可以暂时理解为Java地线程Thread。语法非常简单，就是在调用需要异步执行的方法前加上go关键字： 12f() // call f(); 同步调用，等待返回go f() // 创建 goroutine调用f(); 不等待结果，当前goroutine继续执行下面地代码 1.goroutine1.1 交互体验当程序在做复杂性高的工作，用户等待在那里得不到响应，用户体验非常差，所以我们通常看到有很多应用会展示进度条或者一朵菊花似的圈圈在那转（如图），以提示用户等待⌛️。 下面是一个最简单的样例，在执行fib斐波那契数列计算时，并发地打印等待的圈圈spinner。两个独立执行单元分别在独立的函数中，但两个函数会并发地执行（cpu多核的情况可以同时执行，非多核是两个单元轮流执行一个时间片）。 123456func main() { go spinner(100 * time.Millisecond) // 并发执行函数spinner const n = 45 fibN := fib(n) // slow 递归深度大，执行效率低 fmt.Printf(&quot;\\rFibonacci(%d) = %d\\n&quot;, n, fibN)} 执行结果：一直旋转，直到fib返回 主函数main也执行结束，主函数返回时，所有的goroutine都会被直接打断，程序退出。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但可以通过goroutine之间的通信来让一个goroutine A 请goroutine B，并让goroutine B自行结束执行。 1.2 服务端一个TCP服务端如果只能同步执行，那一次只能处理一个请求，执行结果如下，第一个客户端连接，能后拿到响应；第二个客户端连接了 1234567891011121314151617181920212223242526// TCP 服务端func main() { listener, err := net.Listen(&quot;tcp&quot;, &quot;localhost:8000&quot;) if err != nil { log.Fatal(err) } for { conn, err := listener.Accept() // 监听连接，有连接进来返回一个连接 if err != nil { log.Print(err) // e.g., connection aborted continue } handleConn(conn) // 一次只能处理一个连接，一直等到这个函数返回，才能下个循环响应下一个连接 }}// 返回给客户端当前时间，死循环，一直不能退出func handleConn(c net.Conn) { defer c.Close() for { _, err := io.WriteString(c, time.Now().Format(&quot;15:04:05\\n&quot;)) if err != nil { return // e.g., client disconnected } time.Sleep(1 * time.Second) }} 服务端程序只需要做一点小改动，就能使其支持并发：在handleConn函数调用的地方增加go关键字，让每一次handleConn的调用都进入一个独立的goroutine。 12345for { conn, err := listener.Accept() // 省略错误处理 go handleConn(conn) // 并发地处理每个连接} 2.Channelschannel是一个通信机制，它可以让goroutine A给另一个goroutine B发送信息。类似于Java的BlockQueue，通过线程间共享阻塞队列叨叨通过和传递数据的目的。 每个channel都有一个类型，也就是channel可发送数据的类型，类似于Java ArrayList容器中的类型，如发送int类型数据的channel一般写为chan int。 channel有发送和接收两个主要操作，都是通信行为。 1234567891011// 创建ch := make(chan int) // 定义一个传输int数据的channel，返回底层数据结构的引用ch = make(chan int) // 无缓冲区ch = make(chan int, 0) // 无缓冲区ch = make(chan int, 3) // 带大小为3的缓冲区// ch &lt;- x // 发送xx = &lt;-ch // 接收并赋值给x&lt;-ch // 接收并丢弃 close(ch) goroutine A 将一个值通过channel发送到另一个执行接收操作的goroutine B。 发送和接收都使用**&lt;-**运算符，方向左，ch在左表示发送，ch在右表示接收。 操作 操作数顺序 发送 ch &lt;- x(ch在左，箭头方向是把x发给ch中) 接收 x = &lt;-ch(x在左，类似于赋值range接收) 关闭 close(ch) 2.0 最简易用法：12345678910111213var ch chan string = make(chan string) // ch has type 'chan int' func main() { fmt.Printf(&quot;%T\\n&quot;, ch) go receive() ch &lt;- &quot;send from main&quot; close(ch)}// receive from channelfunc receive() { x := &lt;-ch fmt.Println(&quot;rev:&quot;+x)} 2.1 无缓存channel &amp; 同步一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到接收者goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。类似于Java的1大小的BlockQueue。 由于发送和接收是阻塞的操作，可以通过channel进行同步。 123456789101112131415func main() { conn, err := net.Dial(&quot;tcp&quot;, &quot;localhost:8000&quot;) if err != nil { log.Fatal(err) } done := make(chan struct{}) // 空类型的通道 go func() { // 异步routine io.Copy(os.Stdout, conn) // 打印服务端响应 log.Println(&quot;done&quot;) done &lt;- struct{}{} // 发送 }() mustCopy(conn, os.Stdin) // 发送请求到服务端 conn.Close() &lt;-done // 主线程阻塞在通道上等待异步routine发送完} 2.2 串联的Channels（pipeline）对于pipeline管道可能很熟悉，shell中用于串联多个进程，而go中就是串联goroutine， 当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。 没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。 1234x, ok := &lt;-naturalsif !ok { break //通道已经关闭了，接收不到值了} 但上面的方式有点不方便，可以用range直接遍历 123for x := range naturals { // 依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环 squares &lt;- x * x} 与网络连接或者文件不同，不一定要关闭channel，只有需要signal接收者goroutine发送完毕时才需要关闭channel。 或者不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。 2.3 单向channel12out chan&lt;- int // 发送in &lt;-chan int // 接收 隐式转换：任何双向channel向单向channel变量的赋值操作都将导致该隐式转换，可以隐式地从chan int转换成chan&lt;- int，也可以转换为&lt;-chan int。 这里并没有反向转换的语法：不能将一个chan&lt;- int或者 &lt;-channel int类型转换为chan int类型的双向型的channel。 2.4 带缓存buffer的Channel带缓存的Channel持有一个元素队列，类似于Java的BlockQueue，队列容量cap在调用make创建channel时第二个参数指定。 下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。 1234ch = make(chan string, 3) cap(ch) // 获取容量len(ch) // 发送了多少个元素 发送就是入队，接收操作则是出队。 如果内部缓存队列是满的，发送将阻塞直到因另一个goroutine执行接收操作而释放了新空间。 相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。 那么channel的缓存队列将不是满的也不是空的，因此发送或接收操作都不会发生阻塞。这样就解耦了接收和发送的goroutine。 channel可以是多对多的，不一定是一对一的。 goroutines泄漏：当goroutines阻塞在channel上，泄漏的goroutines不会被自动回收，应确保不再需要的goroutine能正常退出是重要的。 2.5 并发的循环并发处理通常在循环中，并行处理类似的事情。与前面将函数闭包时一样，如果在循环中引用外部变量，存在快照问题，最终使用的是同一个变量，而不是枚举过程中不断迭代的变量。所以需要显式地定义局部变量，而不是直接使用外部变量。 12345678910for _, f := range filenames { // 异步处理 go thumbnail.ImageFile(f) // 闭包引用 外部变量 错误！！！} for _, f := range filenames { go func(f string) { // 显式变量f，非闭包引用，否则变量快照问题 thumbnail.ImageFile(f) }(f)} 2.6 join等待通常会需要主线程等待自线程执行完成后再退出，否则整个程序退出了，自线程没有处理完成。但是没有提供显式的方法完成这个功能，通常通过channel发送事件。 12345678910111213func makeThumbnails3(filenames []string) { ch := make(chan struct{}) for _, f := range filenames { go func(f string) { thumbnail.ImageFile(f) ch &lt;- struct{}{} // 每个线程处理完才会发送信号 }(f) } // 主线程等待所有子线程处理完成后，接收事件信号 for range filenames { &lt;-ch }} 2.6.1计数sync.WaitGroup类似于countDownLatch的功能，WaitGroup通常用于等待一组线程执行完成，就是上一个例子中主线程等待子线程完成后退出的功能。 sync.WaitGroup拥有一个内部计数器。当计数器等于0时，则Wait()方法会立即返回。否则它将阻塞执行Wait()方法的goroutine直到计数器等于0时为止。 1234567891011121314var wg sync.WaitGroup // number of working goroutines 工作线程数 类似于countdownlatchfor f := range filenames { wg.Add(1) // worker go func(f string) { defer wg.Done() ... }(f)}go func() { // 堵塞此goroutine，如果放在main之中，堵塞main goroutine wg.Wait() close(sizes)}() 在启动一个线程时Add，一个线程退出时Done，最终用Wait等待其状态到0。 2.6.2 chennel信号量无限制地新增线程并发处理，不一定可以提高效率，与计算机硬件有关；而且可能会耗尽更有限地资源，所以需要控制并发数量。就像Java地线程池指定大小来控制并发，go可以通过信号量来控制这一点，信号量也是通过channel来实现的。 channel也可以实现信号量，类似Java中的Samphore信号量，用一个有容量限制的buffered channel来控制并发，channel里的n个空槽代表n个可以处理内容的token(通行证)，只有先占了一个槽，线程才能继续执行。 12345678var tokens = make(chan struct{}, 20) func crawl(url string) []string { tokens &lt;- struct{}{} // 获取信号量，发送到有缓冲的channel，如果满了，则阻塞等待 list, err := links.Extract(url) &lt;-tokens // 处理完成，释放信号量 return list} 2.7 select多路复用类似于IO的select多路复用，用于线程监听多个io信号，处理多个io事件，减少io阻塞等待的事件，go中channel也有阻塞的情况，所以也就有了select多路复用的场景，以优化性能。 12345678910select {case &lt;-ch1: // ...case x := &lt;-ch2: // ...use x...case ch3 &lt;- y: // ...default: // ...} select会等待case中有能够执行的case时去执行。如case &lt;-ch1指ch1中可以接收数据，就会执行这个case 下的语句，如果没有的话会阻塞。当条件满足时，select才会去通信并执行case之后的语句；这时候其它case是不会执行的。当有多个case都满足时，随机选择一个case进行。 一个没有任何case的select语句写作select{}，会永远地等待下去。select还可以指定default子句，没有满足的case会执行default。 channel的零值是nil，对一个nil的channel发送和接收会永远阻塞，永远都不会被select到。 123456select {case &lt;-abort: fmt.Printf(&quot;Launch aborted!\\n&quot;) returndefault: // do nothing 2.8 goroutine退出类似于Java中线程A调用B的中断方法将其中断位置位，线程B处理逻辑中检查其中断位并退出这样的设计才能实现一个线程停止另一个线程。go中可以定一个channel，线程A向channel发送中断信号，线程B在多路复用select从channel中接收中断信号，如果接收到了退出。 但是如果我们想要退出两个或者任意多个goroutine怎么办呢？一对多广播 关闭了一个channel并且被消费掉了所有已发送的值，接收操作会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播 123456789101112131415var done = make(chan struct{}) func cancelled() bool { select { case &lt;-done: return true default: return false }} go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte close(done)// 关闭通道，实现广播，所有cancel方法进入第一个case，不再阻塞}()","link":"/2022/06/02/go_goroutine_channel/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"gopl","slug":"gopl","link":"/tags/gopl/"}],"categories":[{"name":"git","slug":"git","link":"/categories/git/"},{"name":"vim","slug":"vim","link":"/categories/vim/"},{"name":"go","slug":"go","link":"/categories/go/"}],"pages":[{"title":"资源","text":"","link":"/resources/index.html"},{"title":"gopl","text":"title: gittype: tagsdate: 2023-03-23 11:14:54 title: gotype: tagsdate: 2023-03-23 11:14:54","link":"/tags/index.html"},{"title":"关于","text":"","link":"/about/index.html"},{"title":"go","text":"title: gittype: categoriesdate: 2023-03-23 11:14:54","link":"/categories/index.html"}]}