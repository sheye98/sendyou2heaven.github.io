<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.goroutine&amp;channel</title>
      <link href="/2022/06/02/go_goroutine_channel/"/>
      <url>/2022/06/02/go_goroutine_channel/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>应用程序通常需要</p><ol><li><strong>图形化界面异步</strong>执行一部分代码，以提升<strong>交互体验</strong></li><li>需要并发地执行以提升<strong>效率</strong></li><li>服务端并发处理连接，提升<strong>响应速度和qps</strong></li></ol><p>这些功能都是通过并发实现地，在<a href="https://so.csdn.net/so/search?q=Go%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020">Go语言</a>中，每一个并发的执行单元叫作一个<strong>goroutine</strong>，可以暂时理解为Java地线程<strong>Thread</strong>。语法非常简单，就是在调用需要异步执行的方法前加上<strong>go</strong>关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f()    <span class="comment">// call f(); 同步调用，等待返回</span></span><br><span class="line"><span class="keyword">go</span> f() <span class="comment">// 创建 goroutine调用f(); 不等待结果，当前goroutine继续执行下面地代码</span></span><br></pre></td></tr></table></figure><h1 id="1-goroutine"><a href="#1-goroutine" class="headerlink" title="1.goroutine"></a><strong><strong>1.goroutine</strong></strong></h1><h2 id="1-1-交互体验"><a href="#1-1-交互体验" class="headerlink" title="1.1 交互体验"></a><strong><strong>1.1 交互体验</strong></strong></h2><p>当程序在做复杂性高的工作，用户等待在那里得不到响应，用户体验非常差，所以我们通常看到有很多应用会展示进度条或者一朵菊花似的圈圈在那转（如图），以提示用户等待⌛️。</p><p>下面是一个最简单的样例，在执行<strong>fib</strong>斐波那契数列计算时，并发地打印等待的圈圈<strong>spinner。</strong>两个独立<strong>执行单元</strong>分别在独立的<strong>函数</strong>中，但两个函数会<strong>并发</strong>地执行（cpu多核的情况可以同时执行，非多核是两个单元轮流执行一个时间片）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)<span class="comment">// 并发执行函数spinner</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">fibN := fib(n) <span class="comment">// slow 递归深度大，执行效率低</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：一直旋转，直到fib返回 主函数main也执行结束，主函数返回时，所有的goroutine都会被直接打断，程序退出。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但可以通过goroutine之间的通信来让一个goroutine A 请goroutine B，并让goroutine B自行结束执行。</p><h2 id="1-2-服务端"><a href="#1-2-服务端" class="headerlink" title="1.2 服务端"></a><strong><strong>1.2 服务端</strong></strong></h2><p>一个TCP服务端如果只能同步执行，那一次只能处理一个请求，执行结果如下，第一个客户端连接，能后拿到响应；第二个客户端连接了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()<span class="comment">// 监听连接，有连接进来返回一个连接</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err) <span class="comment">// e.g., connection aborted</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">handleConn(conn) <span class="comment">// 一次只能处理一个连接，一直等到这个函数返回，才能下个循环响应下一个连接</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回给客户端当前时间，死循环，一直不能退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err := io.WriteString(c, time.Now().Format(<span class="string">&quot;15:04:05\n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// e.g., client disconnected</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端程序只需要做一点小改动，就能使其支持并发：在<strong>handleConn</strong>函数<strong>调用</strong>的地方增加<strong>go</strong>关键字，让每一次handleConn的调用都进入一个独立的goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="comment">// 省略错误处理</span></span><br><span class="line">    <span class="keyword">go</span> handleConn(conn) <span class="comment">// 并发地处理每个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Channels"><a href="#2-Channels" class="headerlink" title="2.Channels"></a><strong><strong>2.Channels</strong></strong></h1><p>channel是一个通信机制，它可以让goroutine A给另一个goroutine B发送信息。类似于Java的BlockQueue，通过线程间共享阻塞队列叨叨通过和传递数据的目的。</p><p>每个channel都有一个类型，也就是channel可发送数据的类型，类似于Java ArrayList<Integer>容器中的类型，如发送int类型数据的channel一般写为chan int。</p><p>channel有发送和接收两个主要操作，都是通信行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 定义一个传输int数据的channel，返回底层数据结构的引用</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)    <span class="comment">// 无缓冲区</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 无缓冲区</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 带大小为3的缓冲区</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">ch &lt;- x  <span class="comment">// 发送x</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 接收并赋值给x</span></span><br><span class="line">&lt;-ch     <span class="comment">// 接收并丢弃</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>goroutine A 将一个值通过channel<strong>发送</strong>到另一个<strong>执行接收操作</strong>的goroutine B。</p><p>发送和接收都使用**<code>&lt;-</code>**运算符，方向左，ch在左表示发送，ch在右表示接收。</p><table><thead><tr><th>操作</th><th>操作数顺序</th></tr></thead><tbody><tr><td>发送</td><td>ch &lt;- x(ch在左，箭头方向是把x发给ch中)</td></tr><tr><td>接收</td><td>x &#x3D; &lt;-ch(x在左，类似于赋值range接收)</td></tr><tr><td>关闭</td><td>close(ch)</td></tr></tbody></table><h2 id="2-0-最简易用法："><a href="#2-0-最简易用法：" class="headerlink" title="2.0 最简易用法："></a><strong><strong>2.0 最简易用法：</strong></strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// ch has type &#x27;chan int&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, ch)</span><br><span class="line"><span class="keyword">go</span> receive()</span><br><span class="line">ch &lt;- <span class="string">&quot;send from main&quot;</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// receive from channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">()</span></span>  &#123;</span><br><span class="line">x := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;rev:&quot;</span>+x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-无缓存channel-amp-同步"><a href="#2-1-无缓存channel-amp-同步" class="headerlink" title="2.1 无缓存channel &amp; 同步"></a><strong><strong>2.1 无缓存channel &amp; 同步</strong></strong></h2><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到接收者goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。类似于Java的1大小的BlockQueue。</p><p>由于发送和接收是阻塞的操作，可以通过channel进行同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8000&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 空类型的通道</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">// 异步routine</span></span><br><span class="line">io.Copy(os.Stdout, conn) <span class="comment">// 打印服务端响应</span></span><br><span class="line">log.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 发送 </span></span><br><span class="line">&#125;()</span><br><span class="line">mustCopy(conn, os.Stdin)<span class="comment">// 发送请求到服务端</span></span><br><span class="line">conn.Close()</span><br><span class="line">&lt;-done <span class="comment">// 主线程阻塞在通道上等待异步routine发送完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-串联的Channels（pipeline）"><a href="#2-2-串联的Channels（pipeline）" class="headerlink" title="2.2 串联的Channels（pipeline）"></a><strong><strong>2.2 串联的Channels（pipeline）</strong></strong></h2><p>对于pipeline管道可能很熟悉，shell中用于串联多个进程，而go中就是串联goroutine，</p><p><img src="https://img-blog.csdnimg.cn/20200522164430107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhcmFmaW5hNTI3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200522164430107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhcmFmaW5hNTI3,size_16,color_FFFFFF,t_70"></p><p>当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，<strong>后续的接收操作将不再阻塞</strong>，它们会立即返回一个零值。</p><p>没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，<strong>多接收的第二个结果是一个布尔值ok</strong>，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, ok := &lt;-naturals</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span> <span class="comment">//通道已经关闭了，接收不到值了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面的方式有点不方便，可以用<strong>range</strong>直接遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;<span class="comment">// 依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环</span></span><br><span class="line">squares &lt;- x * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与网络连接或者文件不同，不<strong>一定</strong>要关闭channel，只有需要<strong>signal</strong>接收者goroutine<strong>发送完毕</strong>时才需要关闭channel。</p><p>或者不管一个channel是否被关闭，当它<strong>没有被引用</strong>时将会被Go语言的垃圾自动回收器<strong>回收</strong>。</p><h2 id="2-3-单向channel"><a href="#2-3-单向channel" class="headerlink" title="2.3 单向channel"></a><strong><strong>2.3 单向channel</strong></strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out <span class="keyword">chan</span>&lt;- <span class="type">int</span>    <span class="comment">// 发送</span></span><br><span class="line">in &lt;-<span class="keyword">chan</span> <span class="type">int</span>    <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><p>隐式转换：任何双向channel向单向channel变量的赋值操作都将导致该隐式转换，可以隐式地从chan int转换成chan&lt;- int，也可以转换为&lt;-chan int。</p><p>这里并没有反向转换的语法：不能将一个chan&lt;- int或者 &lt;-channel int类型转换为chan int类型的双向型的channel。</p><h2 id="2-4-带缓存buffer的Channel"><a href="#2-4-带缓存buffer的Channel" class="headerlink" title="2.4 带缓存buffer的Channel"></a><strong>2.4 带缓存buffer的Channel</strong></h2><p>带缓存的<strong>Channel</strong>持有一个<strong>元素队列，类似于Java的BlockQueue，</strong>队列容量cap在调用make创建channel时第二个参数指定。</p><p>下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cap</span>(ch) <span class="comment">// 获取容量</span></span><br><span class="line"><span class="built_in">len</span>(ch) <span class="comment">// 发送了多少个元素</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200522175435457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhcmFmaW5hNTI3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200522175435457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhcmFmaW5hNTI3,size_16,color_FFFFFF,t_70"></p><p>发送就是入队，接收操作则是出队。</p><p>如果内部缓存队列是满的，发送将阻塞直到因另一个goroutine执行接收操作而释放了新空间。</p><p>相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p><p>那么channel的缓存队列将不是满的也不是空的，因此发送或接收操作都不会发生阻塞。这样就解耦了接收和发送的goroutine。</p><p>channel可以是多对多的，不一定是一对一的。</p><p>goroutines泄漏：当goroutines阻塞在channel上，泄漏的goroutines不会被自动回收，应确保不再需要的goroutine能正常退出是重要的。</p><h2 id="2-5-并发的循环"><a href="#2-5-并发的循环" class="headerlink" title="2.5 并发的循环"></a><strong><strong>2.5 并发的循环</strong></strong></h2><p>并发处理通常在循环中，并行处理类似的事情。与前面将函数闭包时一样，如果在循环中引用外部变量，存在快照问题，最终使用的是同一个变量，而不是枚举过程中不断迭代的变量。所以需要显式地定义局部变量，而不是直接使用外部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line"><span class="comment">// 异步处理</span></span><br><span class="line"><span class="keyword">go</span> thumbnail.ImageFile(f) <span class="comment">// 闭包引用 外部变量 错误！！！</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;<span class="comment">// 显式变量f，非闭包引用，否则变量快照问题</span></span><br><span class="line">thumbnail.ImageFile(f) </span><br><span class="line">&#125;(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-join等待"><a href="#2-6-join等待" class="headerlink" title="2.6 join等待"></a><strong><strong>2.6 join等待</strong></strong></h2><p>通常会需要主线程等待自线程执行完成后再退出，否则整个程序退出了，自线程没有处理完成。但是没有提供显式的方法完成这个功能，通常通过channel发送事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails3</span><span class="params">(filenames []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">thumbnail.ImageFile(f) </span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;<span class="comment">// 每个线程处理完才会发送信号</span></span><br><span class="line">&#125;(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主线程等待所有子线程处理完成后，接收事件信号</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> filenames &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-1计数sync-WaitGroup"><a href="#2-6-1计数sync-WaitGroup" class="headerlink" title="2.6.1计数sync.WaitGroup"></a><strong><strong>2.6.1计数sync.WaitGroup</strong></strong></h3><p>类似于countDownLatch的功能，WaitGroup通常用于等待一组线程执行完成，就是上一个例子中主线程等待子线程完成后退出的功能。</p><p><code>sync.WaitGroup</code>拥有一个内部计数器。当计数器等于<code>0</code>时，则<code>Wait()</code>方法会立即返回。否则它将阻塞执行<code>Wait()</code>方法的<code>goroutine</code>直到计数器等于<code>0</code>时为止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// number of working goroutines 工作线程数 类似于countdownlatch</span></span><br><span class="line"><span class="keyword">for</span> f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// worker</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">...</span><br><span class="line">&#125;(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 堵塞此goroutine，如果放在main之中，堵塞main goroutine</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(sizes)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>在启动一个线程时Add，一个线程退出时Done，最终用Wait等待其状态到0。</p><h3 id="2-6-2-chennel信号量"><a href="#2-6-2-chennel信号量" class="headerlink" title="2.6.2 chennel信号量"></a><strong><strong>2.6.2 chennel信号量</strong></strong></h3><p>无限制地新增线程并发处理，不一定可以提高效率，与计算机硬件有关；而且可能会耗尽更有限地资源，所以需要控制并发数量。就像Java地线程池指定大小来控制并发，go可以通过信号量来控制这一点，信号量也是通过channel来实现的。</p><p>channel也可以实现信号量，类似Java中的Samphore信号量，用一个有<strong>容量限制</strong>的<strong>buffered channel</strong>来控制并发，channel里的n个空槽代表n个可以处理内容的<strong>token</strong>(通行证)，只有先占了一个槽，线程才能继续执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取信号量，发送到有缓冲的channel，如果满了，则阻塞等待</span></span><br><span class="line">    list, err := links.Extract(url)</span><br><span class="line">    &lt;-tokens <span class="comment">// 处理完成，释放信号量</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-select多路复用"><a href="#2-7-select多路复用" class="headerlink" title="2.7 select多路复用"></a><strong><strong>2.7 select多路复用</strong></strong></h2><p>类似于IO的select多路复用，用于线程监听多个io信号，处理多个io事件，减少io阻塞等待的事件，go中channel也有阻塞的情况，所以也就有了select多路复用的场景，以优化性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">    <span class="comment">// ...use x...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select会等待case中有能够执行的case时去执行。如case &lt;-ch1指ch1中可以接收数据，就会执行这个case 下的语句，如果没有的话会阻塞。当条件满足时，select才会去通信并执行case之后的语句；这时候其它case是不会执行的。当有多个case都满足时，随机选择一个case进行。</p><p>一个没有任何case的select语句写作select{}，会永远地等待下去。select还可以指定default子句，没有满足的case会执行default。</p><p>channel的零值是nil，对一个nil的channel<strong>发送和接收</strong>会永远<strong>阻塞</strong>，永远都不会被select到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-abort:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Launch aborted!\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// do nothing</span></span><br></pre></td></tr></table></figure><h2 id="2-8-goroutine退出"><a href="#2-8-goroutine退出" class="headerlink" title="2.8 goroutine退出"></a><strong><strong>2.8 goroutine退出</strong></strong></h2><p>类似于Java中线程A调用B的中断方法将其中断位置位，线程B处理逻辑中检查其中断位并退出这样的设计才能实现一个线程停止另一个线程。go中可以定一个channel，线程A向channel发送中断信号，线程B在多路复用select从channel中接收中断信号，如果接收到了退出。</p><p>但是如果我们想要退出两个或者任意多个goroutine怎么办呢？一对多广播</p><p>关闭了一个channel并且被消费掉了所有已发送的值，接收操作会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Stdin.Read(<span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)) <span class="comment">// read a single byte</span></span><br><span class="line">    <span class="built_in">close</span>(done)<span class="comment">// 关闭通道，实现广播，所有cancel方法进入第一个case，不再阻塞</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> gopl </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
